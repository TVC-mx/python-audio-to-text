name: Deploy to Azure VM

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Azure CLI
      uses: azure/login@v1
      with:
        creds: |
          {
            "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
            "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
            "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
            "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
          }
    
    - name: Get VM and Key Vault Info
      id: get-vm-info
      run: |
        echo "ðŸ” Obteniendo informaciÃ³n completa de VM y recursos..."
        
        # Buscar VM que coincida con el patrÃ³n tvc-audio2text-*-vm-* en toda la suscripciÃ³n
        VM_INFO=$(az vm list \
          --query "[?contains(name, 'tvc-audio2text') && contains(name, 'vm')]" \
          --output json | jq '.[0]')
        
        if [ "$VM_INFO" = "null" ] || [ -z "$VM_INFO" ]; then
          echo "âŒ No se encontrÃ³ VM con patrÃ³n tvc-audio2text-*-vm-*"
          exit 1
        fi
        
        # Extraer informaciÃ³n de la VM
        VM_NAME=$(echo "$VM_INFO" | jq -r '.name')
        RESOURCE_GROUP=$(echo "$VM_INFO" | jq -r '.resourceGroup')
        LOCATION=$(echo "$VM_INFO" | jq -r '.location')
        
        echo "ðŸ” VM encontrada: $VM_NAME"
        echo "ðŸ“¦ Grupo de recursos: $RESOURCE_GROUP"
        echo "ðŸ“ UbicaciÃ³n: $LOCATION"
        
        # Obtener IP de la VM
        VM_IP=$(az vm show \
          --resource-group "$RESOURCE_GROUP" \
          --name "$VM_NAME" \
          --show-details \
          --query publicIps \
          --output tsv)
        
        # Buscar Key Vault en el mismo grupo de recursos
        KEY_VAULT_NAME=$(az keyvault list \
          --resource-group "$RESOURCE_GROUP" \
          --query "[0].name" \
          --output tsv)
        
        if [ -z "$KEY_VAULT_NAME" ]; then
          echo "âŒ No se encontrÃ³ Key Vault en el grupo de recursos: $RESOURCE_GROUP"
          exit 1
        fi
        
        echo "ðŸ”‘ Key Vault encontrado: $KEY_VAULT_NAME"
        
        # Guardar variables de salida
        echo "vm-ip=$VM_IP" >> $GITHUB_OUTPUT
        echo "vm-name=$VM_NAME" >> $GITHUB_OUTPUT
        echo "resource-group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
        echo "location=$LOCATION" >> $GITHUB_OUTPUT
        echo "key-vault-name=$KEY_VAULT_NAME" >> $GITHUB_OUTPUT
        echo "VM IP: $VM_IP"
        echo "Key Vault: $KEY_VAULT_NAME"
    
    - name: Get SSH Key from Key Vault
      id: get-ssh-key
      run: |
        echo "ðŸ”‘ Obteniendo clave SSH desde Key Vault..."
        echo "ðŸ” Key Vault: ${{ steps.get-vm-info.outputs.key-vault-name }}"
        
        # El workflow detecta automÃ¡ticamente la SSH key con patrÃ³n tvc-audio2text-*-ssh-key-*
        
        # Buscar SSH key con patrÃ³n tvc-audio2text-*-ssh-key-* (excluyendo -name)
        SSH_KEY_NAME=$(az keyvault secret list \
          --vault-name ${{ steps.get-vm-info.outputs.key-vault-name }} \
          --query "[?contains(name, 'tvc-audio2text') && contains(name, 'ssh-key') && !contains(name, '-name')].name" \
          --output tsv | head -1)
        
        if [ -z "$SSH_KEY_NAME" ]; then
          echo "âŒ No se encontrÃ³ SSH key con patrÃ³n tvc-audio2text-*-ssh-key-*"
          echo "ðŸ“‹ Secrets disponibles en Key Vault:"
          az keyvault secret list \
            --vault-name ${{ steps.get-vm-info.outputs.key-vault-name }} \
            --query "[].name" \
            --output table || echo "No se pudieron listar secrets"
          exit 1
        fi
        
        echo "ðŸ”‘ SSH Key encontrada: $SSH_KEY_NAME"
        
        # Obtener clave privada desde Key Vault usando la SSH key detectada
        SSH_PRIVATE_KEY=$(az keyvault secret show \
          --vault-name ${{ steps.get-vm-info.outputs.key-vault-name }} \
          --name "$SSH_KEY_NAME" \
          --query value \
          --output tsv)
        
        # Verificar que la clave no estÃ© vacÃ­a
        if [ -z "$SSH_PRIVATE_KEY" ]; then
          echo "âŒ La clave SSH estÃ¡ vacÃ­a en Key Vault"
          exit 1
        fi
        
        # Verificar formato de la clave SSH
        echo "ðŸ” Verificando formato de la clave SSH..."
        if echo "$SSH_PRIVATE_KEY" | head -1 | grep -q "BEGIN.*PRIVATE KEY"; then
          echo "âœ… Formato de clave SSH vÃ¡lido"
        else
          echo "âš ï¸ Clave SSH no estÃ¡ en formato PEM, intentando decodificar Base64..."
          # Intentar decodificar Base64
          SSH_PRIVATE_KEY=$(echo "$SSH_PRIVATE_KEY" | base64 -d 2>/dev/null || echo "$SSH_PRIVATE_KEY")
          
          # Verificar nuevamente
          if echo "$SSH_PRIVATE_KEY" | head -1 | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "âœ… Clave SSH decodificada correctamente"
          else
            echo "âŒ Formato de clave SSH invÃ¡lido. Debe comenzar con 'BEGIN ... PRIVATE KEY'"
            echo "ðŸ” Primeras lÃ­neas de la clave:"
            echo "$SSH_PRIVATE_KEY" | head -3
            exit 1
          fi
        fi
        
        # Guardar clave SSH en archivo temporal (mÃ¡s seguro que variable)
        echo "$SSH_PRIVATE_KEY" > /tmp/ssh_private_key
        chmod 600 /tmp/ssh_private_key
        
        echo "âœ… Clave SSH obtenida desde Key Vault: ${{ steps.get-vm-info.outputs.key-vault-name }}"
        echo "ðŸ“ Clave SSH guardada en archivo temporal"
    
    - name: Setup SSH
      run: |
        echo "ðŸ”‘ Configurando SSH agent..."
        
        # Iniciar SSH agent
        eval "$(ssh-agent -s)"
        
        # Agregar clave SSH desde archivo temporal
        ssh-add /tmp/ssh_private_key
        
        # Verificar que la clave se agregÃ³ correctamente
        ssh-add -l
        
        echo "âœ… SSH agent configurado correctamente"
    
    - name: Deploy to VM
      run: |
        echo "ðŸš€ Desplegando a VM usando clave de Terraform/Key Vault..."
        
        # Crear script de deploy
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ðŸš€ Iniciando deploy en VM..."
        
        # Detener contenedores existentes
        echo "ðŸ›‘ Deteniendo contenedores existentes..."
        docker-compose -f azure-gpu-optimized.yml down || true
        
        # Limpiar imÃ¡genes antiguas
        echo "ðŸ§¹ Limpiando imÃ¡genes antiguas..."
        docker system prune -f || true
        
        # Clonar/actualizar repositorio
        echo "ðŸ“¥ Actualizando cÃ³digo..."
        if [ -d "python-audio-to-text" ]; then
          cd python-audio-to-text
          git pull origin main
        else
          git clone https://github.com/TVC-mx/python-audio-to-text.git
          cd python-audio-to-text
        fi
        
        # Verificar que .env existe
        if [ ! -f ".env" ]; then
          echo "âš ï¸ Archivo .env no encontrado, copiando desde env.example..."
          cp env.example .env
          echo "ðŸ“ Por favor, configura las variables de entorno en .env"
        fi
        
        # Crear directorios necesarios
        mkdir -p audios textos logs
        
        # Construir y ejecutar con GPU
        echo "ðŸ³ Construyendo y ejecutando con GPU..."
        docker-compose -f azure-gpu-optimized.yml up --build -d
        
        # Verificar que el contenedor estÃ¡ corriendo
        echo "âœ… Verificando estado del contenedor..."
        docker ps
        
        echo "ðŸŽ‰ Deploy completado exitosamente!"
        EOF
        
        chmod +x deploy.sh
        
        # Ejecutar deploy en la VM
        echo "ðŸš€ Desplegando a VM: ${{ steps.get-vm-info.outputs.vm-name }}"
        scp -o StrictHostKeyChecking=no deploy.sh azureuser@${{ steps.get-vm-info.outputs.vm-ip }}:/home/azureuser/
        ssh -o StrictHostKeyChecking=no azureuser@${{ steps.get-vm-info.outputs.vm-ip }} "cd /home/azureuser && ./deploy.sh"
    
    - name: Verify deployment
      run: |
        echo "ðŸ” Verificando deploy..."
        ssh -o StrictHostKeyChecking=no azureuser@${{ steps.get-vm-info.outputs.vm-ip }} "
          echo 'ðŸ“Š Estado del sistema:'
          docker ps
          echo ''
          echo 'ðŸŽ® Estado GPU:'
          nvidia-smi --query-gpu=utilization.gpu,memory.used,memory.total --format=csv,noheader,nounits || echo 'GPU no disponible'
          echo ''
          echo 'ðŸ’¾ Uso de memoria:'
          free -h
        "
